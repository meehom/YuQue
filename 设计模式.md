[https://www.yuque.com/u21195183/fnz31h](https://www.yuque.com/u21195183/fnz31h)


## 设计模式七大原则

---

常用的七大原则有：

- 1）单一职责原则
- 2）接口隔离原则
- 3）依赖倒转原则
- 4）里氏替换原则
- 5）开闭原则
- 6）迪米特法则
- 7）合成复用原则

### 

### 单一职责原则
> 对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2

原始：类里面方法处理了多个职责
```java
public class SingleResponsibility1 {
    public static void main(String[] args) {
        Vehicle vehicle = new Vehicle();
        vehicle.run("汽车");
        vehicle.run("轮船");
        vehicle.run("飞机");
    }
}

/**
 * 方式1的分析
 * 1.在方式1的run方法中，违反了单一职责原则
 * 2.解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可
 */
class Vehicle{
    public void run(String type){
        if ("汽车".equals(type)) {
            System.out.println(type + "在公路上运行...");
        } else if ("轮船".equals(type)) {
            System.out.println(type + "在水面上运行...");
        } else if ("飞机".equals(type)) {
            System.out.println(type + "在天空上运行...");
        }
    }
}
```
改进1：在类层面改进代码，通过多个类实现了单一职责
```java
public class SingleResponsibility2 {
    public static void main(String[] args) {
        RoadVehicle roadVehicle = new RoadVehicle();
        roadVehicle.run("汽车");
        WaterVehicle waterVehicle = new WaterVehicle();
        waterVehicle.run("轮船");
        AirVehicle airVehicle = new AirVehicle();
        airVehicle.run("飞机");
    }
}

/**
 * 方案2的分析
 * 1.遵守单一职责原则
 * 2.但是这样做的改动很大，即将类分解，同时修改客户端
 * 3.改进：直接修改Vehicle类，改动的代码会比较少=>方案3
 */
class RoadVehicle{
    public void run(String type){
        System.out.println(type + "在公路上运行...");
    }
}
class WaterVehicle{
    public void run(String type){
        System.out.println(type + "在水面上运行...");
    }
}
class AirVehicle{
    public void run(String type){
        System.out.println(type + "在天空上运行...");
    }
}
```
改进2：在方法层面改进代码，通过把方法隔离开实现单一职责
```java
public class SingleResponsibility3 {
    public static void main(String[] args) {
        Vehicle2 vehicle = new Vehicle2();
        vehicle.run("汽车");
        vehicle.runWater("轮船");
        vehicle.runAir("飞机");
    }
}

/**
 * 方式3的分析
 * 1.这种修改方法没有对原来的类做大的修改，只是增加方法
 * 2.这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责
 */
class Vehicle2{
    public void run(String type){
        System.out.println(type + "在公路上运行...");
    }
    public void runWater(String type){
        System.out.println(type + "在水面上运行...");
    }
    public void runAir(String type){
        System.out.println(type + "在天空上运行...");
    }
}
```

细节

- 1）降低类的复杂度，一个类只负责一项职责
- 2）提高类的可读性，可维护性
- 3）降低变更引起的风险
- 4）通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

### 接口隔离原则
> 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上


原始
```java
interface Interface1 {
    void operation1();

    void operation2();

    void operation3();

    void operation4();

    void operation5();
}

class B implements Interface1 {

    @Override
    public void operation1() {
        System.out.println("B 实现了 operation1");
    }

    @Override
    public void operation2() {
        System.out.println("B 实现了 operation2");
    }

    @Override
    public void operation3() {
        System.out.println("B 实现了 operation3");
    }

    @Override
    public void operation4() {
        System.out.println("B 实现了 operation4");
    }

    @Override
    public void operation5() {
        System.out.println("B 实现了 operation5");
    }
}

class D implements Interface1 {

    @Override
    public void operation1() {
        System.out.println("D 实现了 operation1");
    }

    @Override
    public void operation2() {
        System.out.println("D 实现了 operation2");
    }

    @Override
    public void operation3() {
        System.out.println("D 实现了 operation3");
    }

    @Override
    public void operation4() {
        System.out.println("D 实现了 operation4");
    }

    @Override
    public void operation5() {
        System.out.println("D 实现了 operation5");
    }
}

/**
 * A类通过接口Interface1依赖（使用）B类，但是只会用到1，2，3方法
 */
class A {
    public void depend1(Interface1 i) {
        i.operation1();
    }

    public void depend2(Interface1 i) {
        i.operation2();
    }

    public void depend3(Interface1 i) {
        i.operation3();
    }
}

/**
 * C类通过接口Interface1依赖（使用）D类，但是只会用到1，4，5方法
 */
class C {
    public void depend1(Interface1 i) {
        i.operation1();
    }

    public void depend4(Interface1 i) {
        i.operation4();
    }

    public void depend5(Interface1 i) {
        i.operation5();
    }
}
```

- 1）类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C 来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法
- 2）将接口 Interface1 拆分为独立的几个接口，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则
- 3）接口 Interface1 中出现的方法，根据实际情况拆分为三个接口

![image.png](https://cdn.nlark.com/yuque/0/2022/png/27426792/1649508534793-80eefb50-e625-4140-89d8-60c41a69d22a.png#clientId=u5252d1ba-f452-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=502&id=u3c0595d2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=502&originWidth=907&originalType=binary&ratio=1&rotation=0&showTitle=false&size=194482&status=done&style=none&taskId=u49d9e565-9d60-4ab9-be0d-6f2709867a9&title=&width=907)
改进：
```java
interface Interface1 {
    void operation1();
}

interface Interface2 {
    void operation2();

    void operation3();
}

interface Interface3 {
    void operation4();

    void operation5();
}

class B implements Interface1, Interface2 {

    @Override
    public void operation1() {
        System.out.println("B 实现了 operation1");
    }

    @Override
    public void operation2() {
        System.out.println("B 实现了 operation2");
    }

    @Override
    public void operation3() {
        System.out.println("B 实现了 operation3");
    }
}

class D implements Interface1, Interface3 {

    @Override
    public void operation1() {
        System.out.println("D 实现了 operation1");
    }

    @Override
    public void operation4() {
        System.out.println("D 实现了 operation4");
    }

    @Override
    public void operation5() {
        System.out.println("D 实现了 operation5");
    }
}

/**
 * A类通过接口Interface1,Interface2依赖（使用）B类，但是只会用到1，2，3方法
 */
class A {
    public void depend1(Interface1 i) {
        i.operation1();
    }

    public void depend2(Interface2 i) {
        i.operation2();
    }

    public void depend3(Interface2 i) {
        i.operation3();
    }
}

/**
 * C类通过接口Interface1,Interface3依赖（使用）D类，但是只会用到1，4，5方法
 */
class C {
    public void depend1(Interface1 i) {
        i.operation1();
    }

    public void depend4(Interface3 i) {
        i.operation4();
    }

    public void depend5(Interface3 i) {
        i.operation5();
    }
}
```


### 依赖倒转原则
> 面向接口编程

- 1）高层模块不应该依赖低层模块，二者都应该依赖其抽象
- 2）抽象不应该依赖细节，细节应该依赖抽象
- 3）依赖倒转（倒置）的中心思想是面向接口编程
- 4）依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类
- 5）使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

原始
```java
/**
 * 方式1分析
 * 1.简单，比较容易想到
 * 2.如果我们获取的对象是微信，短信等等，则新增类，同时 Peron也要增加相应的接收方法
 * 3.解决思路：
 * 引入一个抽象的接口IReceiver，表示接收者，这样Person类与接口IReceiver发生依赖
 * 因为Email，Weixin等等属于接收的范围，他们各自实现IReceiver接口就ok，这样我们就符号依赖倒转原则
 */
class Email {
    public String getInfo() {
        return "电子邮件信息：Hello World！";
    }
}

class Person {
    public void receive(Email email) {
        System.out.println(email.getInfo());
    }
}
```
改进：抽线出一个接口，使得增加新的实现时可以不必修改调用端代码
```java
interface IReceiver {
    String getInfo();
}

class Email implements IReceiver {
    @Override
    public String getInfo() {
        return "电子邮件信息：Hello World！";
    }
}

class Weixin implements IReceiver {
    @Override
    public String getInfo() {
        return "微信消息：Hello World！";
    }
}

class ShortMessage implements IReceiver {
    @Override
    public String getInfo() {
        return "短信信息：Hello World！";
    }
}

class Person {
    public void receive(IReceiver receiver) {
        System.out.println(receiver.getInfo());
    }
}
```


### 里氏替换原则
> 在子类中尽量不要重写父类的方法，可以通过聚合、组合、依赖来解决问题

原始
```java
public void test() {
    A a = new A();
    System.out.println("11-3=" + a.func1(11, 3));
    System.out.println("1-8=" + a.func1(1, 8));
    System.out.println("---------------------");

    B b = new B();
    System.out.println("11-3=" + b.func1(11, 3));
    System.out.println("1-8=" + b.func1(1, 8));
    System.out.println("11+3+9=" + b.func2(11, 3));
}

class A {
    //返回两个数的差
    public int func1(int num1, int num2) {
        return num1 - num2;
    }
}

class B extends A {
    @Override
    public int func1(int num1, int num2) {
        return num1 + num2;
    }

    //增加了一个新功能：完成两个数相加，然后和9求和
    public int func2(int num1, int num2) {
        return func1(num1, num2) + 9;
    }
}
```
改进
```java
//创建一个更加基础的基类
class Base {
    //将更基础的成员和方法写到Base类中
}

class A extends Base {
    //返回两个数的差
    public int func1(int num1, int num2) {
        return num1 - num2;
    }
}

class B extends Base {
    //如果B需要使用A类的方法，使用组合关系
    private A a;

    public int func1(int num1, int num2) {
        return num1 + num2;
    }

    //增加了一个新功能：完成两个数相加，然后和9求和
    public int func2(int num1, int num2) {
        return func1(num1, num2) + 9;
    }

    public int func3(int num1, int num2) {
        return this.a.func1(num1, num2);
    }
}
```

### 开闭原则
> 对扩展开放（对提供者而言），对修改关闭（对使用者而言）

原始
```java
class GraphicEditor {
    public void drawShape(Shape s) {
        if (s.m_type == 1) {
            drawRectangle(s);
        } else if (s.m_type == 2) {
            drawCircle(s);

        } else if (s.m_type == 3) {
            drawTriangle(s);
        }
    }

    public void drawRectangle(Shape r) {
        System.out.println("矩形");
    }

    public void drawCircle(Shape r) {
        System.out.println("圆形");
    }

    public void drawTriangle(Shape r) {
        System.out.println("三角形");
    }
}

class Shape {
    public int m_type;
}

class RectangleShape extends Shape {
    RectangleShape() {
        m_type = 1;
    }
}

class CircleShape extends Shape {
    CircleShape() {
        m_type = 2;
    }
}

class TriangleShape extends Shape {
    TriangleShape() {
        m_type = 3;
    }
}
```

改进
```java
class GraphicEditor {
    public void drawShape(Shape s) {
        s.draw();
    }
}

abstract class Shape {
    int m_type;

    public abstract void draw();
}

class RectangleShape extends Shape {
    RectangleShape() {
        m_type = 1;
    }

    @Override
    public void draw() {
        System.out.println("矩形");
    }
}

class CircleShape extends Shape {
    CircleShape() {
        m_type = 2;
    }

    @Override
    public void draw() {
        System.out.println("圆形");
    }
}

class TriangleShape extends Shape {
    TriangleShape() {
        m_type = 3;
    }

    @Override
    public void draw() {
        System.out.println("三角形");
    }
}
```

### 迪米特法则
> 只与直接的朋友通信，降低类之间的耦合

原始
```java
//总部员工
class Employee {
    private String id;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
}

//学院员工
class CollegeEmployee {
    private String id;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
}

//学院员工管理 类
class CollegeManager {
    public List<CollegeEmployee> getAllEmployee() {
        List<CollegeEmployee> list = new ArrayList<>();
        CollegeEmployee collegeEmployee;
        for (int i = 0; i < 10; i++) {
            collegeEmployee = new CollegeEmployee();
            collegeEmployee.setId("学院员工id=" + i);
            list.add(collegeEmployee);
        }
        return list;
    }
}

//总部员工管理类
class SchoolManager {
    public List<Employee> getAllEmployee() {
        List<Employee> list = new ArrayList<>();
        Employee employee;
        for (int i = 0; i < 5; i++) {
            employee = new Employee();
            employee.setId("总部员工id=" + i);
            list.add(employee);
        }
        return list;
    }

    public void printAllEmployee(CollegeManager sub) {
        System.out.println("--------------学院员工--------------");
        List<CollegeEmployee> list1 = sub.getAllEmployee();
        for (CollegeEmployee collegeEmployee : list1) {
            System.out.println(collegeEmployee.getId());
        }
        System.out.println("---------------总部员工-------------");
        List<Employee> list2 = this.getAllEmployee();
        for (Employee employee : list2) {
            System.out.println(employee.getId());
        }
    }
}
```

### 合成复用原则
> 尽量使用合成/聚合的方式，而不是使用继承




## UML类图

---

```java
public class Person {
    private Integer id;
    private String name;
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return name;
    }
}
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/27426792/1649510880358-1d3bf262-42ed-4f80-a033-9ba1fe5fb7b3.png#clientId=u5252d1ba-f452-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=u2a1d0372&margin=%5Bobject%20Object%5D&name=image.png&originHeight=233&originWidth=441&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88374&status=done&style=none&taskId=u9f637d29-85ad-4873-9844-3d52924499f&title=&width=441)

### 依赖关系
> 只要是在类中用到了对方，那么他们之间就存在依赖关系

```java
public class PersonServiceBean {
    // 类的成员属性
    private PersonDao personDao;

    // 方法接收的参数类型
    public void save(Person person) {
    }

    // 方法的返回类型
    public IDCard getIDCard(Integer personid) {
        return null;
    }

    // 方法中使用到
    public void modify() {
        Department department = new Department();
    }

}
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/27426792/1649510990395-a5b5312e-9af8-4612-bdaf-e89e8c42bfd4.png#clientId=u5252d1ba-f452-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=418&id=ufeaa32bc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=932&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75959&status=done&style=none&taskId=u12bd56dc-d827-4298-a6f0-a6293ade727&title=&width=932)


### 泛化关系
> 泛化关系实际上就是继承关系，它是依赖关系的特例

```java
public abstract class DaoSupport {
    public void save(Object entity) {
    }

    public void delete(Object id) {
    }
}
public class PersonServiceBean extends DaoSupport {
}
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/27426792/1649511044505-40c4869d-ffe1-4dd1-8d58-0fad411df4a5.png#clientId=u5252d1ba-f452-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=349&id=ufd829aee&margin=%5Bobject%20Object%5D&name=image.png&originHeight=349&originWidth=409&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35407&status=done&style=none&taskId=u9ebc286f-6d36-4e1c-9361-f1f5b8fbd26&title=&width=409)

### 实现关系
> 实现关系实际上就是 A 类实现 B 类，它是依赖关系的特例

```java
public interface PersonService {
    void delete(Integer id);
}
public class PersonServiceBean implements PersonService {
    @Override
    public void delete(Integer id) {
        System.out.println("delete...");
    }
}
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/27426792/1649511111936-ad9f60f2-59c8-4212-9629-7469a55a109d.png#clientId=u5252d1ba-f452-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=353&id=u267dba3e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=353&originWidth=411&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36031&status=done&style=none&taskId=u6ec4a4be-6f93-4e54-b837-d842b15cac6&title=&width=411)

### 关联关系
> 关联关系实际上就是类与类之间的联系，它是依赖关系的特例

```java
public class Person {
	private IDCard card;
}
public class IDCard {}
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/27426792/1649511167361-3953de02-b7f2-436b-97e3-cab1a8e6a39d.png#clientId=u5252d1ba-f452-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=307&id=u9195da7e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=307&originWidth=310&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20991&status=done&style=none&taskId=u43569039-f1e5-44b2-af3c-4fe95f130aa&title=&width=310)

### 聚合关系
> 聚合关系表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例

```java
public class Mouse {}
public class Monitor {}
public class Computer {
    private Mouse mouse;
    private Monitor monitor;

    public void setMouse(Mouse mouse) {
        this.mouse = mouse;
    }

    public void setMonitor(Monitor monitor) {
        this.monitor = monitor;
    }
}
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/27426792/1649511276472-97cac385-6ffa-4d5b-8163-f3bbba19dd0c.png#clientId=u5252d1ba-f452-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=364&id=uf29b9f2c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=364&originWidth=477&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37686&status=done&style=none&taskId=uf86e0d35-159e-4cc4-ae30-f4f80955371&title=&width=477)


### 组合关系
> 组合关系也是整体与部分的关系，但是整体与部分不可以分开

```java
public class Mouse {}
public class Monitor {}
public class Computer {
    private Mouse mouse = new Mouse();
    private Monitor monitor = new Monitor();
}
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/27426792/1649511345018-1ee48aa9-6675-4464-b33e-c349f0da9d3d.png#clientId=u5252d1ba-f452-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=338&id=ud9701f49&margin=%5Bobject%20Object%5D&name=image.png&originHeight=338&originWidth=463&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41731&status=done&style=none&taskId=u9b710e1b-148b-4229-9973-82c21fe906d&title=&width=463)


## 创造型模式

---


### 单例模式
> 对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法），比如 Hibernate 的 SessionFactory


八种方式

- 1）饿汉式（静态常量）
- 2）饿汉式（静态代码块）
- 3）懒汉式（线程不安全）
- 4）懒汉式（线程安全，同步方法）
- 5）懒汉式（线程安全，同步代码块）
- 6）双重检查
- 7）静态内部类
- 8）枚举

#### 1 饿汉式（静态常量）
```java
public class Singleton {
    // 1、构造器私有化
    private Singleton() {
    }

    // 2、类的内部创建对象
    private static final Singleton instance = new Singleton();

    // 3、向外暴露一个静态的公共方法
    public static Singleton getInstance() {
        return instance;
    }
}
```
缺点：没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费

#### 2 饿汉式（静态代码块）
```java
public class Singleton {
    // 1、构造器私有化
    private Singleton() {
    }

    // 2、类的内部声明对象
    private static Singleton instance;

    // 3、在静态代码块中创建对象
    static {
        instance = new Singleton();
    }

    // 4、向外暴露一个静态的公共方法
    public static Singleton getInstance() {
        return instance;
    }
}
```
缺点：和静态常量一样，内存浪费


#### 3 懒汉式（线程不安全）
```java
// 1、构造器私有化
private Singleton() {
}

// 2、类的内部声明对象
private static Singleton instance;

// 3、向外暴露一个静态的公共方法，当使用到该方法时，才去创建 instance
public static Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    return instance;
}
```
起到了 Lazy Loading 的效果，但是只能在单线程下使用


#### 4 懒汉式（线程安全，同步方法）
```java
public class Singleton {
    // 1、构造器私有化
    private Singleton() {
    }

    // 2、类的内部声明对象
    private static Singleton instance;

    // 3、向外暴露一个静态的公共方法，加入同步处理的代码，解决线程安全问题
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
效率太低了

#### 5 懒汉式（线程安全，同步代码块）
```java
public class Singleton {
    // 1、构造器私有化
    private Singleton() {
    }

    // 2、类的内部声明对象
    private static Singleton instance;

    // 3、向外暴露一个静态的公共方法，加入同步处理的代码，解决线程安全问题
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                instance = new Singleton();
            }
        }
        return instance;
    }
}
```
不能起到线程同步的作用。假如一个线程进入了判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例

#### 6 双重检查
```java
public class Singleton {
    // 1、构造器私有化
    private Singleton() {
    }

    // 2、类的内部声明对象，同时用`volatile`关键字修饰修饰
    private static volatile Singleton instance;

    // 3、向外暴露一个静态的公共方法，加入同步处理的代码块，并进行双重判断，解决线程安全问题
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
线程安全；延迟加载；效率较高。在实际开发中，推荐使用这种单例设计模式

#### 7 静态内部类
```java
public class Singleton {
    // 1、构造器私有化
    private Singleton() {
    }

    // 2、定义一个静态内部类，内部定义当前类的静态属性
    private static class SingletonInstance {
        private static final Singleton instance = new Singleton();
    }

    // 3、向外暴露一个静态的公共方法
    public static Singleton getInstance() {
        return SingletonInstance.instance;
    }
}
```
静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用`getlnstance`方法，才会装载Singletonlnstance 类，从而完成 Singleton 的实例化
避免了线程不安全，利用静态内部类特点实现延迟加载，效率高

#### 8 枚举
```java
public enum Singleton {
    INSTANCE;

    public void sayHello() {
        System.out.println("Hello World");
    }
}
```

**总结：**
单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多但又经常用到的对象（即：重量级对象）、工具类对象、频繁访问数据库或文件的对象（比如数据源、session 工厂等）

![image.png](https://cdn.nlark.com/yuque/0/2022/png/27426792/1649512665933-0b7224e6-1134-49ce-9ec9-3f7fa00c8077.png#clientId=u5252d1ba-f452-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=532&id=u469a82c2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=532&originWidth=993&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60565&status=done&style=none&taskId=u83e62fb9-8dd0-429f-b44f-4b8df1b6003&title=&width=993)


### 工厂模式

#### 1 简单工厂模式
![image.png](https://cdn.nlark.com/yuque/0/2022/png/27426792/1649512819889-c87a731d-639f-44ba-89fd-4ce3836e21d4.png#clientId=u5252d1ba-f452-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=712&id=u485c8097&margin=%5Bobject%20Object%5D&name=image.png&originHeight=712&originWidth=592&originalType=binary&ratio=1&rotation=0&showTitle=false&size=94746&status=done&style=none&taskId=ub98495c3-7766-4a34-8db0-89a3ce5c36a&title=&width=592)
```java
public class PizzaFactory {
    public Pizza createPizza(String orderType) {
        Pizza pizza = null;
        switch (orderType) {
            case "cheese":
                pizza = new CheesePizza();
                break;
            case "greek":
                pizza = new GreekPizza();
                break;
            case "pepper":
                pizza = new PepperPizza();
                break;
            default:
                break;
        }
        return pizza;
    }
}

public class OrderPizza {
    private PizzaFactory pizzaFactory;

    public OrderPizza(PizzaFactory pizzaFactory) {
        this.pizzaFactory = pizzaFactory;
        orderPizza();
    }

    public void orderPizza() {
        Pizza pizza = null;
        do {
            pizza = pizzaFactory.createPizza(getType());
            if (pizza == null) {
                System.out.println("Failed to Order Pizza");
            } else {
                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.box();
            }
        } while (true);
    }
    // ...
}
```
#### 
#### 2 静态工厂模式
> 静态工厂模式也是简单工厂模式的一种，只是将工厂方法改为静态方法

```java
public class PizzaFactory {
    public static Pizza createPizza(String orderType) {
        // ...
    }
}

public class OrderPizza {
    public OrderPizza() {
        Pizza pizza;
        do {
            pizza = PizzaFactory.createPizza(getType());
            // ...
        } while (true);
    }
```
#### 
#### 3 工厂方法模式
> 定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类

```java
public abstract class OrderPizza {

    public void orderPizza() {
        Pizza pizza = null;
        do {
            pizza = createPizza(getType());
            if (pizza == null) {
                System.out.println("Failed to Order Pizza");
            } else {
                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.box();
            }
        } while (true);
    }

    public abstract Pizza createPizza(String orderType);
     
    // ...
}

public class LDOrderPizza extends OrderPizza {
    @Override
    public Pizza createPizza(String orderType) {
        Pizza pizza = null;
        switch (orderType) {
            case "cheese":
                pizza = new LDCheesePizza();
                break;
            case "pepper":
                pizza = new LDPepperPizza();
                break;
            default:
                break;
        }
        return pizza;
    }
}

public class BJOrderPizza extends OrderPizza {
    @Override
    public Pizza createPizza(String orderType) {
        Pizza pizza = null;
        switch (orderType) {
            case "cheese":
                pizza = new BJCheesePizza();
                break;
            case "pepper":
                pizza = new BJPepperPizza();
                break;
            default:
                break;
        }
        return pizza;
    }
}
```
#### 4 抽象工厂模式
```java
public interface AbsPizzaFactory {
    Pizza createPizza(String orderType);
}

public class BJPizzaFactory implements AbsPizzaFactory {
    @Override
    public Pizza createPizza(String orderType) {
        Pizza pizza = null;
        switch (orderType) {
            case "cheese":
                pizza = new BJCheesePizza();
                break;
            case "pepper":
                pizza = new BJPepperPizza();
                break;
            default:
                break;
        }
        return pizza;
    }
}

public class LDPizzaFactory implements AbsPizzaFactory {
    @Override
    public Pizza createPizza(String orderType) {
        Pizza pizza = null;
        switch (orderType) {
            case "cheese":
                pizza = new LDCheesePizza();
                break;
            case "pepper":
                pizza = new LDPepperPizza();
                break;
            default:
                break;
        }
        return pizza;
    }
}
```

### 原型模式
> 用原型实例指定创建对象种类，并通过拷贝原型创建新的对象 
> Spring 框架中，创建`ApplicationContext`时，使用的`getBean`方法中使用到了原型模式

原始
```java
public class Sheep {
    private String name;
    private Integer age;

    public Sheep(String name, Integer age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}

public class Client {
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            Sheep sheep = new Sheep("Tom", 1, "白色");
            System.out.println(sheep);
        }
    }
}
```
改进
```java
public class Sheep implements Cloneable {
    private String name;
    private Integer age;
    private String color;

    public Sheep(String name, Integer age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return "Sheep{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", color='" + color + '\'' +
                '}';
    }

    @Override
    protected Object clone() {
        Sheep sheep = null;
        try {
            sheep = (Sheep) super.clone();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return sheep;
    }
}

public class Client {
    public static void main(String[] args) {
        Sheep sheep = new Sheep("Tom", 1, "白色");
        for (int i = 0; i < 10; i++) {
            Sheep sheep1 = (Sheep) sheep.clone();
            System.out.println(sheep1);
        }
    }
}
```
浅拷贝是使用默认的 clone 方法来实现：`sheep=(Sheep)super.clone();`
拓展：深拷贝
深拷贝实现方式 1：重写 clone 方法来实现深拷贝
深拷贝实现方式 2：通过对象序列化实现深拷贝
```java
public class DeepClonableTarget implements Serializable, Cloneable {

    private String cloneName;
    private String cloneClass;

    public DeepClonableTarget(String cloneName, String cloneClass) {
        this.cloneName = cloneName;
        this.cloneClass = cloneClass;
    }

    public String getCloneName() {
        return cloneName;
    }

    public void setCloneName(String cloneName) {
        this.cloneName = cloneName;
    }

    public String getCloneClass() {
        return cloneClass;
    }

    public void setCloneClass(String cloneClass) {
        this.cloneClass = cloneClass;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

public class DeepPrototype implements Serializable, Cloneable {
    private String name;
    private DeepClonableTarget deepClonableTarget;

    public DeepPrototype() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public DeepClonableTarget getDeepClonableTarget() {
        return deepClonableTarget;
    }

    public void setDeepClonableTarget(DeepClonableTarget deepClonableTarget) {
        this.deepClonableTarget = deepClonableTarget;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        //基本数据类型拷贝
        Object object = super.clone();
        //引用类型拷贝
        DeepPrototype deepPrototype = (DeepPrototype) object;
        deepPrototype.deepClonableTarget = (DeepClonableTarget) deepClonableTarget.clone();
        return object;
    }
}

public class DeepTest {
    public static void main(String[] args) throws CloneNotSupportedException {
        DeepPrototype prototype = new DeepPrototype();
        prototype.setName("宋江");
        prototype.setDeepClonableTarget(new DeepClonableTarget("及时雨", "及时雨的类"));

        DeepPrototype clone1 = (DeepPrototype) prototype.clone();
        DeepPrototype clone2 = (DeepPrototype) prototype.clone();
        DeepPrototype clone3 = (DeepPrototype) prototype.clone();
        DeepPrototype clone4 = (DeepPrototype) prototype.clone();
        DeepPrototype clone5 = (DeepPrototype) prototype.clone();
        
        System.out.println(prototype.getName() + ", " + prototype.getDeepClonableTarget().hashCode()); // 宋江, 1554874502
        System.out.println(clone1.getName() + ", " + clone1.getDeepClonableTarget().hashCode()); // 宋江, 1846274136
        System.out.println(clone2.getName() + ", " + clone2.getDeepClonableTarget().hashCode()); // 宋江, 1639705018
        System.out.println(clone3.getName() + ", " + clone3.getDeepClonableTarget().hashCode()); // 宋江, 1627674070
        System.out.println(clone4.getName() + ", " + clone4.getDeepClonableTarget().hashCode()); // 宋江, 1360875712
        System.out.println(clone5.getName() + ", " + clone5.getDeepClonableTarget().hashCode()); // 宋江, 1625635731
    }
}
```
...

### 建造者模式
> java.lang.StringBuilder 中的建造者模式


- 1）Product（产品角色）：一个具体的产品对象
- 2）Builder（抽象建造者）：可建一个 Product 对象的各个部件指定的接口 / 抽象类
- 3）ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件
- 4）Director（指挥者）：构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用 
   - 一是隔离了客户与对象的生产过程
   - 二是负责控制产品对象的生产过程

![image.png](https://cdn.nlark.com/yuque/0/2022/png/27426792/1649514139573-dd0188e7-a270-40a9-950e-ce31252c187a.png#clientId=u5252d1ba-f452-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=441&id=uae359309&margin=%5Bobject%20Object%5D&name=image.png&originHeight=441&originWidth=884&originalType=binary&ratio=1&rotation=0&showTitle=false&size=181088&status=done&style=none&taskId=u6ab06546-83d1-40e8-b9b8-c51476df420&title=&width=884)

原始
```java
public abstract class AbsHouse {
    protected abstract void piling();

    protected abstract void walling();

    protected abstract void capping();

    public void build() {
        piling();
        walling();
        capping();
    }
}

public class NormalRoom extends AbsHouse {
    @Override
    protected void piling() {
        System.out.println("普通房打桩...");
    }

    @Override
    protected void walling() {
        System.out.println("普通房砌墙...");
    }

    @Override
    protected void capping() {
        System.out.println("普通房封顶...");
    }
}

public class HighRise extends AbsHouse {
    @Override
    protected void piling() {
        System.out.println("高楼打桩...");
    }

    @Override
    protected void walling() {
        System.out.println("高楼砌墙...");
    }

    @Override
    protected void capping() {
        System.out.println("高楼封顶...");
    }
}

public class Villa extends AbsHouse {
    @Override
    protected void piling() {
        System.out.println("别墅打桩...");
    }

    @Override
    protected void walling() {
        System.out.println("别墅砌墙...");
    }

    @Override
    protected void capping() {
        System.out.println("别墅封顶...");
    }
}
```
改进
![image.png](https://cdn.nlark.com/yuque/0/2022/png/27426792/1649514173842-15fb6cfa-51eb-43b3-a18a-418836a657ce.png#clientId=u5252d1ba-f452-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=759&id=u52b1ba13&margin=%5Bobject%20Object%5D&name=image.png&originHeight=759&originWidth=1022&originalType=binary&ratio=1&rotation=0&showTitle=false&size=144485&status=done&style=none&taskId=u74d3b368-4d85-4670-8056-536afb298ed&title=&width=1022)
```java
public class House {
    private String pile;
    private String wall;
    private String roof;

    public String getPile() {
        return pile;
    }

    public void setPile(String pile) {
        this.pile = pile;
    }

    public String getWall() {
        return wall;
    }

    public void setWall(String wall) {
        this.wall = wall;
    }

    public String getRoof() {
        return roof;
    }

    public void setRoof(String roof) {
        this.roof = roof;
    }
}

public abstract class HouseBuilder {
    private House house = new House();

    public abstract void piling();
    
    public abstract void walling();
    
    public abstract void capping();

    public House build() {
        return house;
    }
}

public class NormalRoomBuilder extends HouseBuilder {
    @Override
    public void piling() {
        System.out.println("普通房打桩...");
    }

    @Override
    public void walling() {
        System.out.println("普通房砌墙...");
    }

    @Override
    public void capping() {
        System.out.println("普通房封顶...");
    }
}

public class HighRiseBuilder extends HouseBuilder {
    @Override
    public void piling() {
        System.out.println("高楼打桩...");
    }

    @Override
    public void walling() {
        System.out.println("高楼砌墙...");
    }

    @Override
    public void capping() {
        System.out.println("高楼封顶...");
    }
}

public class VillaBuilder extends HouseBuilder {
    @Override
    public void piling() {
        System.out.println("别墅打桩...");
    }

    @Override
    public void walling() {
        System.out.println("别墅砌墙...");
    }

    @Override
    public void capping() {
        System.out.println("别墅封顶...");
    }
}

public class HouseDirector {
    private HouseBuilder houseBuilder;

    public HouseDirector() {
    }

    public void setHouseBuilder(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }

    public House buildHouse() {
        houseBuilder.piling();
        houseBuilder.walling();
        houseBuilder.capping();
        return houseBuilder.build();
    }
}

public class BuilderTest {
    public static void main(String[] args) {
        HouseDirector houseDirector = new HouseDirector();
        House house;

        houseDirector.setHouseBuilder(new NormalRoomBuilder());
        house = houseDirector.buildHouse();
        houseDirector.setHouseBuilder(new HighRiseBuilder());
        house = houseDirector.buildHouse();
        houseDirector.setHouseBuilder(new VillaBuilder());
        house = houseDirector.buildHouse();
    }
}
```
stringbuilder解析

- `Appendable`接口定义了多个`append`方法（抽象方法），即`Appendable`为抽象建造者，定义了抽象方法
- `AbstractStringBuilder`实现了`Appendable`接口方法，这里的`AbstractStringBuilder`已经是建造者，只是不能实例化
- `StringBuilder`既充当了指挥者角色，又充当了具体的建造者，建造方法的实现是由`AbstractStringBuilder`完成，`StringBuilder`继承了`AbstractStringBuilder`

## 结构型模式

---


### 适配器模式
> 适配器模式（Adapter Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器（Wrapper）
> SpringMVC 中的 HandlerAdapter，就使用了适配器模式


#### 1 类适配器模式
```java
// 被适配的类
public class Voltage220V {
    public Integer output220V() {
        int src = 220;
        System.out.println("电压=" + src + "伏");
        return src;
    }
}

// 适配接口
public interface IVoltage5V {
    Integer output5V();
}

// 适配器
public class VoltageAdapter extends Voltage220V implements IVoltage5V {
    @Override
    public Integer output5V() {
        int src = output220V();
        int dst = src / 44;
        System.out.println("电压=" + dst + "伏");
        return dst;
    }
}

// 使用适配器方法
public class Phone {
    public void charing(IVoltage5V iVoltage5V) {
        if (iVoltage5V.output5V() == 5) {
            System.out.println("电压=5伏，正在充电~");
        } else {
            System.out.println("电压!=5伏，无法充电~");
        }
    }
}

// 客户端
public class Client {
    public static void main(String[] args) {
        Phone phone = new Phone();
        phone.charing(new VoltageAdapter());
    }
}
```
缺点： Java 是单继承机制，所以类适配器需要继承 src 类这一点算是一个缺点，适配多个会有问题

#### 2 对象适配器模式
```java
public class VoltageAdapter implements IVoltage5V {
    private Voltage220V voltage220V;

    public VoltageAdapter(Voltage220V voltage220V) {
        this.voltage220V = voltage220V;
    }

    @Override
    public Integer output5V() {
        if (voltage220V == null) {
            return 0;
        }
        int src = voltage220V.output220V();
        int dst = src / 44;
        System.out.println("电压=" + dst + "伏");
        return dst;
    }
}

public class Client {
    public static void main(String[] args) {
        Phone phone = new Phone();
        phone.charing(new VoltageAdapter(new Voltage220V()));
    }
}
```
#### 3 接口适配器模式
```java
public interface Interface4 {
    void operation1();

    void operation2();

    void operation3();

    void operation4();
}

public abstract class AbsAdapter implements Interface4 {
    @Override
    public void operation1() {
    }

    @Override
    public void operation2() {
    }

    @Override
    public void operation3() {
    }

    @Override
    public void operation4() {
    }
}

public class Client {
    public static void main(String[] args) {
        AbsAdapter absAdapter = new AbsAdapter() {
            @Override
            public void operation1() {
                System.out.println("调用operation1方法");
            }
        };
        absAdapter.operation1();
    }
}
```

### 桥接模式
> JDBC 的 Driver 接口

```java
// 行为接口——品牌接口
public interface Branch {
    void open();

    void call();

    void close();
}
// 行为实现类——华为品牌
public class Huawei implements Branch {
    @Override
    public void open() {
        System.out.println("华为手机开机");
    }

    @Override
    public void call() {
        System.out.println("华为手机打电话");
    }

    @Override
    public void close() {
        System.out.println("华为手机关机");
    }
}
// 行为实现类——小米品牌
public class Xiaomi implements Branch {
    @Override
    public void open() {
        System.out.println("小米手机开机");
    }

    @Override
    public void call() {
        System.out.println("小米手机打电话");
    }

    @Override
    public void close() {
        System.out.println("小米手机关机");
    }
}
// 行为实现类——苹果品牌
public class iPhone implements Branch {
    @Override
    public void open() {
        System.out.println("苹果手机开机");
    }

    @Override
    public void call() {
        System.out.println("苹果手机打电话");
    }

    @Override
    public void close() {
        System.out.println("苹果手机关机");
    }
}

// 桥接类——手机抽象类
public abstract class Phone {
    private Branch branch;

    public Phone(Branch branch) {
        this.branch = branch;
    }

    public void open() {
        branch.open();
    }

    public void call() {
        branch.call();
    }

    public void close() {
        branch.close();
    }
}
// 桥接子类——翻盖式手机
public class FlipPhone extends Phone {
    public FlipPhone(Branch branch) {
        super(branch);
        System.out.println("翻盖式手机");
    }

    @Override
    public void open() {
        super.open();
    }

    @Override
    public void call() {
        super.call();
    }

    @Override
    public void close() {
        super.close();
    }
}
// 桥接子类——滑盖式手机
public class SlidePhone extends Phone {
    public SlidePhone(Branch branch) {
        super(branch);
        System.out.println("滑盖式手机");
    }

    @Override
    public void open() {
        super.open();
    }

    @Override
    public void call() {
        super.call();
    }

    @Override
    public void close() {
        super.close();
    }
}
// 桥接子类——直立式手机
public class UprightPhone extends Phone {
    public UprightPhone(Branch branch) {
        super(branch);
        System.out.println("直立式手机");
    }

    @Override
    public void open() {
        super.open();
    }

    @Override
    public void call() {
        super.call();
    }

    @Override
    public void close() {
        super.close();
    }
}
```

### 装饰着模式
> 动态地将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性
> Java 的 IO 结构，FilterlnputStream 就是一个装饰者

```java
// 抽象主体
public abstract class Drink {
    private String desc;
    private Float price;

    public String getDesc() {
        return desc;
    }

    protected void setDesc(String desc) {
        this.desc = desc;
    }

    public Float getPrice() {
        return price;
    }

    protected void setPrice(Float price) {
        this.price = price;
    }

    public abstract Float cost();
}
// 具体主体
public class Coffee extends Drink {

    @Override
    public Float cost() {
        return super.getPrice();
    }
}
public class Decaf extends Coffee {
    public Decaf() {
        setDesc("无因咖啡");
        setPrice(20.0f);
    }
}
public class Espresso extends Coffee {
    public Espresso() {
        setDesc("意大利浓咖");
        setPrice(30.0f);
    }
}
public class ShortBlack extends Coffee {
    public ShortBlack() {
        setDesc("短黑咖啡");
        setPrice(40.0f);
    }
}
public class LongBlack extends Coffee {
    public LongBlack() {
        setDesc("美式咖啡");
        setPrice(50.0f);
    }
}
//装饰者
public class Decorator extends Drink {
    private Drink drink;

    public Decorator(Drink drink) {
        this.drink = drink;
    }

    @Override
    public Float cost() {
        return super.getPrice() + drink.cost();
    }
}
public class Milk extends Decorator {
    public Milk(Drink drink) {
        super(drink);
        setDesc("牛奶");
        setPrice(3.0f);
    }
}
public class Soy extends Decorator {
    public Soy(Drink drink) {
        super(drink);
        setDesc("豆浆");
        setPrice(4.0f);
    }
}
public class Chocolate extends Decorator {
    public Chocolate(Drink drink) {
        super(drink);
        setDesc("巧克力");
        setPrice(5.0f);
    }
}
// 调用者
public class CoffeeBar {
    public static void main(String[] args) {
        Drink drink = new Espresso();
        System.out.println("意大利浓咖：" + drink.cost() + "美元"); // 意大利浓咖：30.0美元

        drink = new Milk(drink);
        System.out.println("意大利浓咖 + 1份牛奶：" + drink.cost() + "美元"); // 意大利浓咖 + 1份牛奶：33.0美元

        drink = new Chocolate(drink);
        System.out.println("意大利浓咖 + 1份牛奶 + 1份巧克力：" + drink.cost() + "美元"); // 意大利浓咖...：38.0美元

        drink = new Chocolate(drink);
        System.out.println("意大利浓咖 + 1份牛奶 + 2份巧克力：" + drink.cost() + "美元"); // 意大利浓咖...：43.0美元
    }
}
```

java源码
```java
// 是一个抽象类，即Component
public abstract class InputStream implements Closeable {} 
// 是一个装饰类，即Decorator
public class FilterInputStream extends InputStream { 
    protected volatile InputStream in;
    protected FilterInputStream(InputStream in) {
        this.in = in;
    }
}
// FilterInputStream子类，也继承了被装饰的对象 in
public class DataInputStream extends FilterInputStream implements DataInput { 
    public DataInputStream(InputStream in) {
        super(in);
    }
```

- 1）InputStream 是抽象类，类似我们前面讲的 Drink
- 2）FileInputStream 是 InputStream 子类，类似我们前面的 DeCaf、LongBlack
- 3）FilterInputStream 是 InputStream 子类，类似我们前面的 Decorator，修饰者
- 4）DataInputStream 是 FilterInputStream 子类，类似前面的Milk，Soy等，具体的修饰者
- 5）FilterInputStream 类有`protected volatile InputStream in;`，即含被装饰者
- 6）分析得出在 JDK 的 IO 体系，就是使用装饰者模式


### 组合模式
> Java 的集合类—— HashMap 就使用了组合模式


### 外观模式
> MyBatis 中 Configuration 去创建 MetaObject 对象时使用到了外观模式


### 享元模式
> 享元模式经典的应用场景就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用
> `Integer.valueOf(x)`方法使用的就是**享元模式**

**          **
### 代理模式
> 静态代理, 动态代理, Cglib 代理


## 行为型模式

---

### 模板方法
```java
/**
 * 抽象方法
 */
public abstract class SoyaMilk {
    /**
     * 模板方法，定义为final禁止覆写
     */
    public final void make() {
        System.out.println(">>>>>>豆浆制作开始<<<<<<");
        useSoyBean();
        addIngredients();
        soak();
        mash();
        System.out.println(">>>>>>豆浆制作结束<<<<<<");
    }

    protected void useSoyBean() {
        System.out.println("Step1. 选用上好的黄豆.");
    }

    protected abstract void addIngredients();

    protected void soak() {
        System.out.println("Step3. 对黄豆和配料进行水洗浸泡.");
    }

    protected void mash() {
        System.out.println("Step4. 将充分浸泡过的黄豆和配料放入豆浆机中，开始打豆浆.");
    }
}
/**
 * 花生豆浆
 */
public class PeanutSoyaMilk extends SoyaMilk {
    public PeanutSoyaMilk() {
        System.out.println("============花生豆浆============");
    }
    @Override
    protected void addIngredients() {
        System.out.println("Step2. 加入上好的花生.");
    }
}
/**
 * 红豆豆浆
 */
public class RedBeanSoyaMilk extends SoyaMilk {
    public RedBeanSoyaMilk() {
        System.out.println("============红豆豆浆============");
    }
    @Override
    protected void addIngredients() {
        System.out.println("Step2. 加入上好的红豆.");
    }
}
/**
 * 芝麻豆浆
 */
public class SesameSoyaMilk extends SoyaMilk {
        public SesameSoyaMilk() {
        System.out.println("============芝麻豆浆============");
    }
    @Override
    protected void addIngredients() {
        System.out.println("Step2. 加入上好的芝麻.");
    }
}
```

### 命令模式
> 将发起请求的对象与执行请求的对象解耦


### 访问者模式
> 解决数据结构和操作耦合性问题


### 迭代器模式
> ArrayList使用了这个


### 观察者模式

### 中介者模式

### 备忘录模式

### 解释器模式

### 状态模式

### 策略模式

### 职责链模式
